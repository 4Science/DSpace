/** * The contents of this file are subject to the license and copyright * detailed in the LICENSE and NOTICE files at the root of the source * tree and available online at * * http://www.dspace.org/license/ */package org.dspace.importer.external.viaf;import java.util.ArrayList;import java.util.Collection;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.concurrent.Callable;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.ObjectMapper;import org.apache.commons.lang3.StringUtils;import org.apache.http.client.utils.URIBuilder;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import org.dspace.content.Item;import org.dspace.importer.external.datamodel.ImportRecord;import org.dspace.importer.external.datamodel.Query;import org.dspace.importer.external.exception.MetadataSourceException;import org.dspace.importer.external.liveimportclient.service.LiveImportClient;import org.dspace.importer.external.service.AbstractImportMetadataSourceService;import org.dspace.importer.external.service.components.QuerySource;import org.dspace.importer.external.viaf.contributors.ViafIdExtractor;import org.springframework.beans.factory.annotation.Autowired;import static org.dspace.importer.external.liveimportclient.service.LiveImportClientImpl.HEADER_PARAMETERS;/** * Implements a data source for querying VIAF (Virtual International Authority File) * It is a service that aggregates authority records from multiple national and international catalogues, * linking them into unified ‘clusters’ for a single entity (author, organisation, etc.). * * @author Mykhaylo Boychuk (mykhaylo.boychuk@4science.com) */public class ViafImportMetadataSourceServiceImpl        extends AbstractImportMetadataSourceService<String> implements QuerySource {    private final static Logger log = LogManager.getLogger(ViafImportMetadataSourceServiceImpl.class);    private final static String VIAF_SOURCE_NAME = "viaf";    private final static String JSON_TYPE = "application/json";    private final static String PATH_TO_RECORDS = "/searchRetrieveResponse/records/record";    private String url;    private String searchUrl;    private final static int timeout = 10000;    @Autowired    private LiveImportClient liveImportClient;    private ViafIdExtractor viafIdExtractor;    @Override    public void init() throws Exception { }    @Override    public String getImportSource() {        return VIAF_SOURCE_NAME;    }    @Override    public ImportRecord getRecord(String id) throws MetadataSourceException {        log.debug("Viaf search by id:{}", id);        if (StringUtils.isBlank(id)) {            return null;        }        return retry(new SearchByIdCallable(id));    }    @Override    public int getRecordsCount(String query) throws MetadataSourceException {        return retry(new CountByQueryCallable(query));    }    @Override    public int getRecordsCount(Query query) throws MetadataSourceException {        return retry(new CountByQueryCallable(query.toString()));    }    @Override    public Collection<ImportRecord> getRecords(String query, int start, int count) throws MetadataSourceException {        return retry(new SearchByQueryCallable(query, start, count));    }    @Override    public Collection<ImportRecord> getRecords(Query query) throws MetadataSourceException {        return retry(new SearchByQueryCallable(query));    }    @Override    public ImportRecord getRecord(Query query) throws MetadataSourceException {        return null;    }    @Override    public Collection<ImportRecord> findMatchingRecords(Query query) throws MetadataSourceException {        return retry(new SearchByQueryCallable(query));    }    @Override    public Collection<ImportRecord> findMatchingRecords(Item item) throws MetadataSourceException {        throw new UnsupportedOperationException("This method is not implemented for:" + VIAF_SOURCE_NAME);    }    private class SearchByIdCallable implements Callable<ImportRecord> {        private String recordId;        private SearchByIdCallable(String id) {            this.recordId = StringUtils.trim(id);        }        @Override        public ImportRecord call() throws Exception {            URIBuilder uriBuilder = new URIBuilder(url + this.recordId);            Map<String, Map<String, String>> params = new HashMap<String, Map<String,String>>();            params.put(HEADER_PARAMETERS, getHeaders());            String response = liveImportClient.executeHttpGetRequest(timeout, uriBuilder.toString(), params);            return StringUtils.isNotBlank(response) ? transformSourceRecords(response) : null;        }    }    private class SearchByQueryCallable implements Callable<List<ImportRecord>> {        private String query;        private Integer start = 1;        private Integer count = 20;        private SearchByQueryCallable(String query, Integer start, Integer count) {            this.query = StringUtils.trim(query);            this.start = start > 0 ? start : this.start;            this.count = count > 0 ? count : this.count;        }        private SearchByQueryCallable(Query query) {            this.query = query.toString();        }        @Override        public List<ImportRecord> call() throws Exception {            List<ImportRecord> results = new ArrayList<>();            var queryParam = String.format("local.personalNames all \"%s\"", query);            log.info("VIAF: search call, query: {}" , queryParam);            URIBuilder uriBuilder = new URIBuilder(searchUrl);            uriBuilder.addParameter("query", queryParam);            uriBuilder.addParameter("startRecord", start.toString());            uriBuilder.addParameter("maximumRecords", count.toString());            Map<String, Map<String, String>> params = new HashMap<String, Map<String,String>>();            params.put(HEADER_PARAMETERS, getHeaders());            String response = liveImportClient.executeHttpGetRequest(timeout, uriBuilder.toString(), params);            if (StringUtils.isEmpty(response)) {                return results;            }            List<String> viafIds = getViafIds(response);            for (String viafId : viafIds) {                ImportRecord record = getRecord(viafId);                if (record != null) {                    results.add(record);                }            }            return results;        }    }    private class CountByQueryCallable implements Callable<Integer> {        private final static String PATH_TO_COUNT = "/searchRetrieveResponse/numberOfRecords/content";        private String query;        private CountByQueryCallable(String queryString) {            query = StringUtils.trim(queryString);        }        @Override        public Integer call() throws Exception {            var queryParam = String.format("local.personalNames all \"%s\"", query);            URIBuilder uriBuilder = new URIBuilder(searchUrl);            uriBuilder.addParameter("query", queryParam);            uriBuilder.addParameter("maximumRecords", "0");            Map<String, Map<String, String>> params = new HashMap<String, Map<String,String>>();            params.put(HEADER_PARAMETERS, getHeaders());            String responseString = liveImportClient.executeHttpGetRequest(1000, uriBuilder.toString(), params);            if (StringUtils.isEmpty(responseString)) {                return 0;            }            JsonNode jsonNode = convertStringJsonToJsonNode(responseString);            return jsonNode.at(PATH_TO_COUNT).asInt();        }    }    private List<String> getViafIds(String response) {        // it start from 2        Integer recordNumberForNameSpace = 2;        JsonNode jsonNode = convertStringJsonToJsonNode(response);        JsonNode recordNode = jsonNode.at(PATH_TO_RECORDS);        if (!recordNode.isArray()) {            var viafId = viafIdExtractor.getViafId(recordNode, recordNumberForNameSpace);            return StringUtils.isNotBlank(viafId) ? List.of(viafId) : List.of();        }        List<String> viafIds = new ArrayList<>();        Iterator<JsonNode> nodes = recordNode.iterator();        while (nodes.hasNext()) {            JsonNode node = nodes.next();            if (!node.isMissingNode()) {                var viafId = viafIdExtractor.getViafId(node, recordNumberForNameSpace);                if (StringUtils.isNotBlank(viafId)) {                    viafIds.add(viafId);                }                recordNumberForNameSpace++;            }        }        return viafIds;    }    private JsonNode convertStringJsonToJsonNode(String json) {        try {            return new ObjectMapper().readTree(json);        } catch (JsonProcessingException e) {            log.error("Unable to process json response.", e);        }        return null;    }    private Map<String, String> getHeaders() {        Map<String, String> headers = new HashMap<String, String>();        headers.put("Accept", JSON_TYPE);        return headers;    }    public void setUrl(String url) {        this.url = url;    }    public void setSearchUrl(String searchUrl) {        this.searchUrl = searchUrl;    }    public void setViafIdExtractor(ViafIdExtractor viafIdExtractor) {        this.viafIdExtractor = viafIdExtractor;    }}